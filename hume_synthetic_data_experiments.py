# -*- coding: utf-8 -*-
"""Hume Synthetic Data Experiments

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1tC924JazlaGxy_MfUcMGaLDIqjqesjOV

# Synthetic Data Generation

Experiments for the paper *Relational Causal Models: a declarative framework for causal inference from relational data*.


Skip over these utility functions:
"""

import random
import pprint
from collections import Counter
import pandas as pd

import numpy as np
import scipy.stats

pp = pprint.PrettyPrinter(indent=4)

def truncated_norm(mu, sigma, lower, upper, n):
    """More intuitive parameterization of truncated normal distribution."""
    a, b = (lower - mu) / sigma, (upper - mu) / sigma
    return scipy.stats.truncnorm.rvs(a, b, loc = mu, scale = sigma, size = n)


def index_of_first(lst):
    """Index of first list element evaluating to true."""
    for i,v in enumerate(lst):
        if v:
            return i
    return None


def multinomial_trial(probs, count):
    """Return the outcomes of several multinomial trials.
    
    probs: list where probs[i] is the probablity class i is selected.
           must sum to 1.
    count: number of trials to perform.
    """
    return [index_of_first(x) for x in np.random.multinomial(1, probs, count)]

"""Let's set the parameters and definitions, from the paper:"""

# Entities, relations, and attributes
E, R, A = {}, {}, {}

dept_code = {
    "math": 0,
    "sci": 1,
    "art": 2,
    "other": 3,
}

# Number of professors
N_p = 5
# Number of students
N_s = 100
# Number of courses
N_c = 7

# Probability a course is difficult
P_d = 0.25
# Probability a student has high aptitude
P_a  = 0.65
# Probability two students are friends
P_f = 1/1000
# Probability student is registered for any course
P_r = 1/125
# Probability student is female
P_g = 1/2

# student attribute generation
A["s_age"] = np.random.randint(17, 23, N_s)
A["s_gender"] = np.random.binomial(1, P_g, N_s)
A["s_gpa"] = truncated_norm(3, 1, 0, 4, N_s)
A["s_major"] = multinomial_trial([1/3, 1/3, 1/6, 1/6], N_s)

# professor attribute generation
A["p_age"] = truncated_norm(45, 10, 25, 70, N_p)
A["p_gender"] = np.random.binomial(1, P_g, N_p)
A["p_rating"] = truncated_norm(4, 1, 0, 5, N_p)
A["p_exp"] = truncated_norm(10, 5, 0, 40, N_p)
A["p_dept"] = multinomial_trial([1/2, 1/3, 1/12, 1/12], N_p)

# course attribute generation
A["c_lvl"] = np.random.randint(1, 6, N_c)
A["c_dept"] = multinomial_trial([1/2, 1/3, 1/12, 1/12], N_c)


# Number of timesteps to use for the Gibbs Sampler
time = 10

"""## Entities"""

E["p"] = {i for i in range(N_p)}
E["s"] = {i for i in range(N_s)}
E["c"] = {i for i in range(N_c)}

"""## Relations"""

def generate_friends(students, p_f):
    """ Generate friendship relationship, an Erdős–Rényi model.
    
        Any two students are friends with probability p,
        No student can be a friend of themselves. All friendship
        is bidirectional.
    """
    friendships = dict()
    for s1 in students:
        friendships.setdefault(s1,[])
        for s2 in students:
            if s1 != s2 and random.random() < p_f:
                friendships[s1].append(s2)
                friendships.setdefault(s2,[]).append(s1)
    return friendships

    
def generate_registration(students, courses, p_r):
    """
        Course registration is a random bipartite
        graph between students and courses. Any
        edge exists with probability p_r.
    """
    registration = dict()
    for s in students:
        registration[s] = []
        for c in courses:
            if random.random() < p_r:
                registration[s].append(c)
    return registration


# student friendships
R["s_s"] = generate_friends(E["s"], P_f)

# student-class registration
R["s_c"] = generate_registration(E["s"], E["c"], P_r)
R["c_p"] = generate_registration(E["c"], E["p"], 2*P_r)

"""## Attributes"""

from scipy.special import expit
from numpy.random import normal, exponential


def tutoring(c_id):
    c_size = sum(1 for _ in filter(lambda cs: c_id in cs,
                                   R["s_c"].values()))
    c_level = A["c_lvl"][c_id]
    dept = A["c_dept"][c_id]
    math_or_sci = dept == dept_code["math"] or dept == dept_code["sci"]
    art = dept == dept_code["art"]
    offset = -2
    p = expit(0.1 * c_size - 2 * c_level + math_or_sci - art + offset)
    return np.random.binomial(1, p)

    
def generate_attendence():
    # initialize lecture attendence completely randomly
    attend = dict()
    for s in R["s_c"]:
        for c in R["s_c"][s]:
            attend[(s, c)] = np.random.randint(0, 101)
    
    # Gibbs sampling
    for t in range(time):
        #print(f"{np.mean(np.stack(attend.values())) * 100}")
        for s in R["s_c"]:
            for c in R["s_c"][s]:            
                f_attend = friends_attending(s, c, attend)
                noise = normal() * 20
                p = expit(f_attend + noise)
                # TODO check the parameterization of the exp distribution
                # there are two common options and they are the opposite of
                # each other.
                attend[(s, c)] = exponential(p * 100 + 10)
    return attend

                
def friends_attending(ego, course, attendence):
    """Return the count of friends attending a course."""
    f_all = R["s_s"][ego]
    f_same_c = [x for x in filter(lambda s: course in R["s_c"][s], f_all)]
    f_att = [attendence[(f, course)] for f in f_same_c]
    return sum(f_att)


def generate_grades():
    grades = dict()
    for s in R["s_c"]:
        for c in R["s_c"][s]:
            factors = (A["s_c_att"][(s, c)]
                       - A["c_lvl"][c] 
                       + 10 * A["c_tutor"][c]
                       - 10)
            grades[(s, c)] = np.around(4 * expit(factors), decimals=1)
    return grades


A["c_tutor"] = [tutoring(c_id) for c_id in E["c"]]
A["s_c_att"] = generate_attendence()
A["s_c_grade"] = generate_grades()

"""# Experiments

We aim to answer two experimental questions:
* EQ1: How effective is HUME in predicting the effect of external interventions ?
* EQ2: Can the summarizing methodology and embedding in latent space recover the actual mappings in the true data generative process?

## EQ1: Predicting Interventions

We evaulate the hypothesis that "intervening by applying tutoring to all courses causes an increase in GPA."  In other words, we seek to evaluate $P(\text{high GPA} | do(\text{tutoring} = \text{yes}))$ for all courses.

We start with the following causal diagram:

<img src="data:image/png;base64,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" style="max-width:100%;" />

We apply backdoor criterion to get the adjustment set:

$ Z = \{level_c\} $

We perform backdoor adjustment:

$ E(\text{GPA}_s | \hat{\text{tutoring}}) = \sum_{\text{level}_c}{E(\text{GPA} | \text{tutoring}, \text{level}_c) P(\text{level}_c)}$

$ E(\text{GPA}_s | \hat{\text{tutoring}}) = E(\text{GPA} | \text{tutoring}, \text{level}_c = 1) P(\text{level}_c = 1) \\ \quad + E(\text{GPA} | \text{tutoring}, \text{level}_c = 2) P(\text{level}_c = 2) \\ \quad + E(\text{GPA} | \text{tutoring}, \text{level}_c = 3) P(\text{level}_c = 3) \\ \quad + E(\text{GPA} | \text{tutoring}, \text{level}_c = 4) P(\text{level}_c = 4)  \\ \quad + E(\text{GPA} | \text{tutoring}, \text{level}_c = 5) P(\text{level}_c = 5) $


Calculate the probablity of each level from the data:
"""

c = Counter(A["c_lvl"])
p_lvl = []
for lvl, count in c.most_common():
    p_lvl.append(count / N_c)

pp.pprint(p_lvl)

"""And now calculate the conditional probabilities in the sum:"""

grades_by_lvl = []
for lvl in range(1, 6):
    c = [x[0] for x in filter(lambda y : y[1] == lvl, enumerate(A["c_lvl"]))]
    c = list(filter(lambda x: A["c_tutor"][x], c))
    grades = [v for k, v in filter(lambda kv: kv[0][1] in c,
                                   A["s_c_grade"].items())]
    grades_by_lvl.append(np.mean(grades))
    print(f"level {lvl}: {np.mean(grades)}")

"""Thus $ P(\text{GPA}_s | \hat{\text{tutoring}}) $ is:"""

e_gpa_tutoring = np.dot(grades_by_lvl, p_lvl)
print(e_gpa_tutoring)

"""Now, we repeat the process for $ P(\text{GPA}_s | \hat{\text{no tutoring}}) $"""

no_tut_grades_by_lvl = []
for lvl in range(1, 6):
    c = [x[0] for x in filter(lambda y : y[1] == lvl, enumerate(A["c_lvl"]))]
    c = list(filter(lambda x: not A["c_tutor"][x], c))
    grades = [v for k, v in filter(lambda kv: kv[0][1] in c,
                                   A["s_c_grade"].items())]
    no_tut_grades_by_lvl.append(np.mean(grades))
    print(f"level {lvl}: {np.mean(grades)}")

"""which results in:"""

e_gpa_no_tutoring = np.dot(no_tut_grades_by_lvl, p_lvl)
print(e_gpa_no_tutoring)

"""And so, the **average causal effect** (ACE) of tutoring on GPA is:"""

print(e_gpa_tutoring - e_gpa_no_tutoring)

"""## EQ2: Summarizations
Here we test HUME's ability to learn the right summarization functions from observed data. We are particularly interested in learning the `Attendence` function, which exhibits contagion.
"""

#entity tables
student_attribute = np.array([ list(E['s']), A['s_age'],A['s_gender'],A['s_major'],A['s_gpa'] ]).T
students = pd.DataFrame(student_attribute,index=list(E['s']),columns=['sid','age','gender','major','gpa'])

prof_attribute = np.array([ list(E['p']), A['p_age'], A['p_gender'], A['p_dept'], A['p_exp'], A['p_rating'] ]).T
professors = pd.DataFrame(prof_attribute, index=list(E['p']), columns=['pid','age','gender','department','experience','ratings'])

course_attribute = np.array([ list(E['c']), A['c_dept'], A['c_lvl'], A['c_tutor'] ]).T
courses = pd.DataFrame(course_attribute, index=list(E['c']), columns = ['cid','department','level','tutoring'])

#relationship tables
sc_table = []
for s,v in R['s_c'].items():
    for c in v:
        sc_table.append([c,s])
course_student_relation = pd.DataFrame(sc_table,columns=['cid','sid'])

cp_table = []
for c,v in R['s_c'].items():
    for p in v:
        sc_table.append([c,p])
course_professor_relation = pd.DataFrame(sc_table,columns=['cid','pid'])

friends_table = []
for s,v in R['s_s'].items():
    for c in v:
        friends_table.append([c,s])
friendship_relation = pd.DataFrame(friends_table,columns=['sid1','sid2'])

# relationship map
D = { 'course' : [ 'cid', [  ('course-student', 'cid', 'sid' , 'student'), ('course-professor','cid', 'pid','professor') ], courses ],
     'student': ['sid', [  ('course-student', 'sid', 'cid', 'course'), ('student-student', 'sid1', 'sid2' , 'student') ], students ],
     'professor': ['pid', [  ('course-professor', 'pid', 'cid', 'course') ], professors ],
     'course-student': [ ('cid', 'sid'), [], course_student_relation ],
     'student-student': [ ('sid1', 'sid2'), [], friendship_relation ],
     'course-professor': [ ('cid', 'pid'), [], course_professor_relation ],
    }


#HUME
import hume
U = hume.make_unit('student',D)
